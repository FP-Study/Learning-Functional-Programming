# 함수형 프로그래밍 2,3장

## 내맘대로 해석한 함수형 프로그래밍 & 범주론

- OOP에서의 함수는 범주론에서 다루는 함수(사상)과 명백히 다르다.

- 그런데 왜 함수형 프로그래밍에서는 귀찮은? 제약(순수성, 고차함수 등)을 추가하면서까지 프로그래밍에서의 함수를 수학의 함수처럼 다루고 싶어하는 걸까? 프로그램에서의 함수를 수학의 함수처럼 다루면 어떤 장점이 있을까?

  가장 큰 장점은 함수의 합성이 가능. 전체 프로그램을 여러가지 함수가 합성된 체인으로 생각할 수 있음

### 그럼 범주론이 함수형 프로그래밍에 어떻게 적용되나?

- 한 프로그래밍 언어 그 자체를 하나 큰 범주로서, 그 언어에서 정의되있는 타입(int, string, ...)이 대상이 되고 그 타입들관의 관계(int->boolean, ...)가 사상이 된다.

  그럼 f: int->int, g: int->string 등의 함수를 정의하고 f\*g: int->string와 같이 합성도 가능하다.

- 다음으로, 펑터(타입 생성자)를 살펴보자.

  범주론에서의 펑터는 범주 사이의 관계를 정의한다. 즉, 범주 내 대상과 대상사이의 관계를 다른 범주로 끌어올린다.

  함수형 프로그래밍에서는 펑터(엔도펑터)는 Functor<T> 타입과 f: Functor<T>->Functor<T> 형태의 함수를 정의해준다.

  그럼 이제 T, Functor<T> 타입과 f:T->T, g:Functor<T>->Functor<T>, h:T->Functor<T> 함수를 얻을 수 있다.

- 하지만, 프로그래밍 언어에는 여러가지의 타입생성자(펑터)가 존재하고 서로 다른 펑터간의 관계도 정의할 필요가 있다.
  엔도펑터에서 엔도펑터로의 사상을 자연변환이라하고, 이를 flatMap을 통해 구현 가능하다.

  따라서, 추가적으로 f:Functor_A<T>->Functor_B<T> 의 함수도 정의할 수 있다.
